'use strict';

/**
 * @returns [array] array of extended bond bonds
 */

module.exports = function (OCL) {
  return function cleaveBonds() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _options$filter = options.filter,
        filter = _options$filter === undefined ? function (bond) {
      return !bond.isAromatic && bond.kind === 1 && bond.ringSize === 0;
    } : _options$filter,
        _options$hose = options.hose,
        hose = _options$hose === undefined ? {
      minSphereSize: 1,
      maxSphereSize: 3
    } : _options$hose;


    var atoms = [];
    for (var i = 0; i < this.getAllAtoms(); i++) {
      var atom = {};
      atoms.push(atom);
      atom.i = i;
      atom.mapNo = this.getAtomMapNo(i);
      atom.links = []; // we will store connected atoms of broken bonds
    }

    var bonds = [];
    for (var _i = 0; _i < this.getAllBonds(); _i++) {
      var _bond = {};
      _bond.i = _i;
      _bond.order = this.getBondOrder(_i);
      _bond.atom1 = this.getBondAtom(0, _i);
      _bond.atom2 = this.getBondAtom(1, _i);
      _bond.kind = this.getBondType(_i);
      _bond.isAromatic = this.isAromaticBond(_i);
      _bond.ringSize = this.getBondRingSize(_i);
      if (filter(_bond)) {
        _bond.selected = true;
        atoms[_bond.atom1].links.push(_bond.atom2);
        atoms[_bond.atom2].links.push(_bond.atom1);
        bonds.push(_bond);
      }
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = bonds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var bond = _step.value;

        bond.fragments = breakMolecule(this, atoms, bond, hose);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return bonds;
  };

  function breakMolecule(molecule, atoms, bond, hoseOptions) {
    var brokenMolecule = molecule.getCompactCopy();
    brokenMolecule.markBondForDeletion(bond.i);
    brokenMolecule.deleteMarkedAtomsAndBonds();
    var fragmentMap = [];
    var nbFragments = brokenMolecule.getFragmentNumbers(fragmentMap);
    var results = [];
    for (var i = 0; i < nbFragments; i++) {
      var result = {};
      result.atomMap = [];
      var includeAtom = fragmentMap.map(function (id) {
        return id === i;
      }); // eslint-disable-line no-loop-func
      var fragment = new OCL.Molecule();
      var atomMap = [];
      brokenMolecule.copyMoleculeByAtoms(fragment, includeAtom, false, atomMap);
      // we will add some R groups at the level of the broken bonds
      fragment.setFragment(false);
      if (atomMap[bond.atom1] > -1) {
        fragment.addBond(atomMap[bond.atom1], fragment.addAtom(154), 1);
        bond.hoses1 = fragment.getHoseCodesForAtom(atomMap[bond.atom1], hoseOptions).map(function (f, i) {
          return { f, i };
        });
      }
      if (atomMap[bond.atom2] > -1) {
        fragment.addBond(atomMap[bond.atom2], fragment.addAtom(154), 1);
        bond.hoses2 = fragment.getHoseCodesForAtom(atomMap[bond.atom2], hoseOptions).map(function (f, i) {
          return { f, i };
        });
      }
      result.idCode = fragment.getIDCode();
      result.mf = fragment.getMF().mf.replace(/R([1-9]|(?=[A-Z(])|$)/, '');
      results.push(result);
    }
    return results;
  }
};